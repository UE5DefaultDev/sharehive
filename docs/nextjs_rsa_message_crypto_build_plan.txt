Do NOT encrypt whole messages with RSA directly. RSA has size limits and is slow.
Use a hybrid scheme:
- AES-256-GCM encrypts the actual message content (fast, arbitrary size)
- RSA-OAEP encrypts (wraps) the AES key (small fixed size)



Key Ownership / Roles
---------------------
A) SERVER KEYPAIR (for inbound encryption to server)
- Server has RSA key pair: server_private_key, server_public_key
- Client encrypts AES key to server_public_key so the server can decrypt.
- Server_private_key must NEVER be shipped to client.
- Store server private key in an environment secret or KMS (recommended).

B) USER KEYPAIR (for outbound encryption to recipients)
- Each user has RSA key pair: user_private_key, user_public_key
- Recipient’s public key is stored on server (public only).
- Recipient decrypts messages locally using their private key.
- Client stores their private key locally (IndexedDB). NOT on server.

Algorithm Specs (MUST MATCH EXACTLY)
-----------------------------------
RSA:
- RSA-OAEP with SHA-256
- Key size: 2048 bits minimum (3072 preferred if you can afford it)
AES:
- AES-GCM
- Key size: 256 bits
- IV/nonce length: 12 bytes (96 bits)
- Tag length: default 128 bits (WebCrypto uses 128)

Encoding:
- All binary blobs are Base64 (standard base64, not base64url unless specified)
- JSON envelopes define fields precisely (see below)

DATA ENVELOPES (STRICT JSON SHAPES)
----------------------------------
1) Client -> Server: EncryptedMessageToServer
Purpose: user encrypts message, server decrypts it and stores plaintext.

{
  "version": 1,
  "senderUserId": "uuid",
  "conversationId": "uuid",
  "sentAt": "ISO-8601 string",
  "cipher": {
    "alg": "AES-256-GCM",
    "iv_b64": "base64(12 bytes)",
    "ciphertext_b64": "base64(...)"
  },
  "key_wrap": {
    "alg": "RSA-OAEP-256",
    "wrapped_key_b64": "base64(RSA_encrypt(server_public_key, aes_key_bytes))"
  },
  "aad": {
    "conversationId": "uuid",
    "senderUserId": "uuid"
  }
}

Notes:
- AES-GCM should include AAD (additional authenticated data) for integrity:
  AAD = JSON string of {conversationId, senderUserId} EXACTLY.

2) Server -> Recipient: EncryptedMessageToRecipient
Purpose: server encrypts plaintext for each recipient with recipient’s public key.

{
  "version": 1,
  "messageId": "uuid",
  "senderUserId": "uuid",
  "recipientUserId": "uuid",
  "conversationId": "uuid",
  "sentAt": "ISO-8601 string",
  "cipher": {
    "alg": "AES-256-GCM",
    "iv_b64": "base64(12 bytes)",
    "ciphertext_b64": "base64(...)"
  },
  "key_wrap": {
    "alg": "RSA-OAEP-256",
    "wrapped_key_b64": "base64(RSA_encrypt(recipient_public_key, aes_key_bytes))"
  },
  "aad": {
    "conversationId": "uuid",
    "senderUserId": "uuid",
    "recipientUserId": "uuid",
    "messageId": "uuid"
  }
}

AAD for recipient messages must include messageId and recipientUserId too.
This prevents replay and cross-user swapping attacks.

DATABASE SCHEMA (MINIMUM VIABLE)
--------------------------------
Table: users
- id (uuid pk)
- email (text unique)
- created_at (timestamp)

Table: user_keys
- user_id (uuid pk, fk users.id)
- public_key_pem (text)          // RSA public key, PEM/SPKI
- key_fingerprint (text)         // sha256 of DER public key (hex)
- created_at (timestamp)
- revoked_at (timestamp nullable)

Table: server_keys (optional if using KMS; otherwise env)
- id (text pk) e.g. "active"
- public_key_pem (text)
- private_key_pem (text encrypted-at-rest) or reference to KMS secret
- rotated_at (timestamp)

Table: messages (plaintext storage, because you demanded it)
- id (uuid pk)
- conversation_id (uuid)
- sender_user_id (uuid)
- plaintext (text)               // decrypted message content
- sent_at (timestamp)
- created_at (timestamp)

Table: message_deliveries (one row per recipient)
- id (uuid pk)
- message_id (uuid fk messages.id)
- recipient_user_id (uuid)
- encrypted_payload_json (jsonb) // EncryptedMessageToRecipient
- delivered_at (timestamp nullable)
- read_at (timestamp nullable)

Key Storage Rules (DON’T MESS THIS UP)
--------------------------------------
Server:
- Store server private key in KMS if possible.
- If not, store in env var (e.g. SERVER_RSA_PRIVATE_KEY_PEM) and ensure:
  - Not in repo
  - Not logged
  - Not sent to client
  - Rotated periodically

Client:
- Store user private key in IndexedDB, not localStorage.
- If you want “multi-device login”, you need key backup/escrow (out of scope).
- If user clears browser storage, they lose ability to decrypt old deliveries.

Key Formats (INTEROP REQUIRED)
------------------------------
Browser WebCrypto uses:
- Public key export: "spki"
- Private key export: "pkcs8"

Server Node crypto uses PEM (SPKI for pub, PKCS8 for private).
So conversion steps are:
- Client exports spki (ArrayBuffer) -> base64 -> wrap as PEM
- Client exports pkcs8 (ArrayBuffer) -> base64 -> wrap as PEM (store locally only)
- When sending public key to server, send PEM (SPKI).

PEM wrapping rules:
- SPKI public key header/footer:
  -----BEGIN PUBLIC KEY-----
  base64 lines
  -----END PUBLIC KEY-----
- PKCS8 private key header/footer:
  -----BEGIN PRIVATE KEY-----
  base64 lines
  -----END PRIVATE KEY-----

ENDPOINTS (NEXT.JS ROUTE HANDLERS)
---------------------------------
1) GET /api/crypto/server-public-key
Returns:
{
  "version": 1,
  "alg": "RSA-OAEP-256",
  "serverPublicKeyPem": "-----BEGIN PUBLIC KEY-----..."
}

2) POST /api/crypto/user-public-key
Auth required.
Body:
{
  "publicKeyPem": "...",
  "fingerprint": "hex sha256"
}
Server verifies:
- PEM parses
- Key is RSA and >= 2048 bits
- Fingerprint matches computed sha256(DER)

3) POST /api/messages/send
Auth required.
Body: EncryptedMessageToServer
Server:
- Decrypt AES key with server private key
- Decrypt message plaintext with AES-GCM
- Validate AAD exactly matches senderUserId + conversationId
- Store plaintext in messages table
- For each recipient in conversation:
  - Generate new random AES key + IV
  - Encrypt plaintext with AES-GCM using recipient AAD
  - RSA-wrap AES key using recipient public key
  - Store EncryptedMessageToRecipient JSON in message_deliveries
Return:
{ "messageId": "uuid" }

4) GET /api/messages/inbox?since=ISO
Auth required.
Returns list of EncryptedMessageToRecipient payloads for the authed user.

Client decrypts each locally using their private key.

CRYPTO OPERATIONS (STEP-BY-STEP)
--------------------------------

CLIENT: USER KEYPAIR GENERATION (one-time per browser)
1) On first login/session check IndexedDB for user private key
2) If missing:
   - Generate RSA-OAEP keypair (modulusLength=2048, publicExponent=65537, hash=SHA-256)
   - Export public (spki) and private (pkcs8)
   - Store private PEM in IndexedDB
   - Compute fingerprint: sha256(DER(spki)) -> hex
   - POST public PEM + fingerprint to /api/crypto/user-public-key

CLIENT: SEND MESSAGE (encrypt to server)
Inputs:
- plaintext (string)
- senderUserId, conversationId
- serverPublicKeyPem from /api/crypto/server-public-key

Steps:
1) Convert plaintext to bytes: UTF-8 encode
2) Generate AES key (256-bit) and IV (12 bytes)
3) Build AAD object: { conversationId, senderUserId }
4) AAD bytes = UTF-8 encode(JSON.stringify(AAD)) with stable ordering:
   MUST always stringify keys in this order: conversationId then senderUserId.
   (If you don’t enforce ordering, your AI implementer will mess it up.)
5) AES-GCM encrypt:
   ciphertext = AES-GCM(aes_key, iv, plaintext_bytes, aad_bytes)
6) Export raw AES key bytes (32 bytes)
7) RSA-OAEP encrypt raw AES key bytes with server public key
8) Base64 encode iv, ciphertext, wrapped_key
9) POST EncryptedMessageToServer JSON to /api/messages/send

SERVER: RECEIVE MESSAGE (decrypt, store plaintext, re-encrypt)
Inputs:
- EncryptedMessageToServer payload

Steps:
1) Parse JSON; check version==1 and alg fields match expected strings
2) Validate sender is authed user (do not trust senderUserId from payload alone)
3) Decode base64 fields -> bytes
4) Rebuild AAD string with exact same key order and values:
   { conversationId, senderUserId }
5) RSA-OAEP decrypt wrapped AES key using server private key -> 32 bytes
6) AES-GCM decrypt ciphertext using AES key, IV, and AAD -> plaintext bytes
   - If auth fails, reject (400) without leaking detail
7) Convert plaintext bytes -> UTF-8 string
8) Store plaintext in DB (messages)
9) Look up conversation recipients (excluding sender)
10) For EACH recipient:
   a) Load recipient public key PEM
   b) Generate fresh AES key + IV (do NOT reuse sender’s AES key)
   c) Build recipient AAD object with key order:
      { conversationId, senderUserId, recipientUserId, messageId }
   d) AES-GCM encrypt plaintext_bytes
   e) RSA-OAEP wrap AES key with recipient public key
   f) Store EncryptedMessageToRecipient JSON in message_deliveries

CLIENT: RECEIVE MESSAGE (decrypt locally)
Inputs:
- EncryptedMessageToRecipient payload
- Recipient private key from IndexedDB

Steps:
1) Decode wrapped_key_b64, iv_b64, ciphertext_b64
2) Rebuild AAD in exact order:
   { conversationId, senderUserId, recipientUserId, messageId }
3) RSA-OAEP decrypt wrapped AES key using recipient private key -> 32 bytes
4) AES-GCM decrypt ciphertext -> plaintext bytes
5) UTF-8 decode -> display

IMPLEMENTATION NOTES (Next.js SPECIFICS)
----------------------------------------
Client components:
- /lib/crypto/client.ts
  - getOrCreateUserKeypair()
  - importServerPublicKey(pem)
  - encryptForServer(plaintext, senderUserId, conversationId, serverPublicKeyPem)
  - decryptFromServer(payload, userPrivateKeyPem)

Server utilities:
- /lib/crypto/server.ts
  - loadServerPrivateKey()
  - decryptFromClient(payload)
  - encryptForRecipient(plaintext, messageMeta, recipientPublicKeyPem)

Route handlers:
- /app/api/crypto/server-public-key/route.ts
- /app/api/crypto/user-public-key/route.ts
- /app/api/messages/send/route.ts
- /app/api/messages/inbox/route.ts

AUTH
----
Every endpoint except server-public-key must require auth.
Never accept userId from payload as truth. Derive from session.

ERROR HANDLING (DO NOT LEAK CRYPTO DETAIL)
------------------------------------------
- Any decrypt failure returns generic 400: "Invalid payload"
- Log only correlation ids, not raw payload bytes or keys

KEY ROTATION (MINIMUM)
----------------------
Server key rotation:
- Keep an “active” server keypair and optionally N old keys for decrypting old inbound payloads.
- Include serverKeyId in EncryptedMessageToServer if you rotate frequently:
  payload.key_wrap.key_id = "serverKey_2026_02"
- For simplicity, start with one key, add rotation later.

User key rotation:
- Add revoke/replace flow by inserting a new user_keys row and marking old revoked_at.
- Deliveries should use the key active at send time.
- If user rotates keys, old deliveries still decrypt with old private key (so don’t delete it).

SECURITY REALITY CHECK (WHAT YOU BUILT)
---------------------------------------
- This is “client-to-server encrypted transport” with server plaintext storage.
- Anyone with server DB access can read everything.
- If you actually wanted privacy, you’d store ciphertext only. You didn’t.

TEST PLAN (REQUIRED, OR YOU’LL SHIP BROKEN CRYPTO)
--------------------------------------------------
1) Interop test vectors
- Generate keys in browser, import on server, encrypt wrap, decrypt unwrap
- Generate keys on server, import on browser, same test

2) Round-trip tests
- Client encrypt -> server decrypt -> server encrypt to recipient -> client decrypt

3) Tamper tests (must fail)
- Flip one bit in ciphertext_b64
- Flip one bit in iv_b64
- Modify AAD fields
All must fail AES-GCM auth

4) Wrong key tests
- Recipient tries decrypt with different user’s private key: must fail

5) Load tests
- Many recipients: ensure per-recipient encryption scales (it’s O(n)).

COMMON FAILURE MODES (AKA: HOW AI IMPLEMENTERS BREAK THIS)
----------------------------------------------------------
- Using RSA-PKCS1v1.5 instead of RSA-OAEP (don’t)
- Encrypting the whole message with RSA (size limit + slow)
- Reusing AES key/IV across recipients (catastrophic with GCM)
- AAD mismatch due to JSON key ordering differences
  -> Enforce stable ordering exactly as specified above.
- Storing private keys in localStorage (don’t)
- Logging keys or payload bytes (don’t)


